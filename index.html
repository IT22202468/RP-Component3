<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Research 1.0 - Electron</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
      h1 { color: #2c3e50; }
      button { padding: 10px 14px; font-size: 16px; border-radius: 6px; cursor: pointer; }
      /* Toast styles */
      .toast-container {
        position: fixed;
        right: 20px;
        bottom: 20px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .toast {
        min-width: 280px;
        max-width: 420px;
        background: #fff;
        color: #222;
        box-shadow: 0 6px 18px rgba(0,0,0,0.12);
        border-radius: 8px;
        padding: 12px 14px;
        display: flex;
        align-items: center;
        gap: 12px;
        animation: toast-in 240ms ease;
      }
      .toast .msg {
        flex: 1 1 auto;
      }
      .toast .actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }
      .toast .actions button {
        padding: 6px 10px;
        font-size: 13px;
        border-radius: 6px;
        border: 1px solid transparent;
        background: #f1f3f5;
        cursor: pointer;
      }
      .toast .actions button.primary {
        background: #2563eb;
        color: #fff;
        border-color: rgba(0,0,0,0.06);
      }
      @keyframes toast-in {
        from { transform: translateY(8px); opacity: 0 }
        to { transform: translateY(0); opacity: 1 }
      }
    </style>
  </head>
  <body>
    <h1>Research 1.0</h1>
    <p>This is a minimal Electron app for the Research project (25-26J-498).</p>
    <p>If you see this window, Electron has launched successfully.</p>

    <div style="margin-top:20px;">
      <button id="notifyBtn">Show Notification</button>
      <span id="status" style="margin-left:12px;color:#666;font-size:14px;"></span>
    </div>

    <div style="margin-top:22px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
      <div>
        <button id="refreshProcs">Refresh Processes</button>
        <span style="margin-left:12px;color:#666;font-size:14px;">(Shows PID, name, cpu%, memory, start time, elapsed, status)</span>
      </div>

      <div style="display:flex;gap:8px;align-items:center;">
        <label style="font-size:13px;color:#444;">Filter:</label>
        <input id="procFilter" placeholder="name or pid" style="padding:6px;border-radius:6px;border:1px solid #ddd;min-width:180px;" />
      </div>

      <div style="display:flex;gap:8px;align-items:center;">
        <label style="font-size:13px;color:#444;">Notify when active</label>
        <input type="checkbox" id="notifyOnActive" />
      </div>

      <div style="display:flex;gap:8px;align-items:center;">
        <label style="font-size:13px;color:#444;">Auto-refresh</label>
        <!-- enabled by default -->
        <input type="checkbox" id="autoRefreshChk" checked />
        <label style="font-size:13px;color:#444;">Interval (s)</label>
        <input type="number" id="autoInterval" value="5" min="1" style="width:64px;padding:6px;border-radius:6px;border:1px solid #ddd;" />
      </div>
    </div>

    <!-- Tabs: All / Ongoing -->
    <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="tabAll" class="tab-btn" style="padding:6px 10px;border-radius:6px;border:1px solid #ddd;background:#fff;">All</button>
        <button id="tabOngoing" class="tab-btn" style="padding:6px 10px;border-radius:6px;border:1px solid #ddd;background:#fff;">Ongoing <span id="ongoingCount" style="font-weight:600;margin-left:6px;color:#555">0</span></button>
      </div>
      <div style="margin-left:8px;color:#666;font-size:13px;">(Ongoing shows processes with status 'ongoing' running &gt; 1 min)</div>
    </div>

    <div style="margin-top:12px; overflow:auto; max-height:320px;">
      <table id="procTable" border="0" cellpadding="6" cellspacing="0" style="width:100%;border-collapse:collapse;margin-top:8px;font-size:13px;">
        <thead>
          <tr style="text-align:left;color:#333;border-bottom:1px solid #e6e6e6;">
            <th>PID</th>
            <th>Name</th>
            <th id="thCpu" style="cursor:pointer">CPU%</th>
            <th id="thMem" style="cursor:pointer">Mem</th>
            <th>Started</th>
            <th>Elapsed</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <script>
      // Use the main process Notification (via IPC) so we can add action buttons.
    // ---------------------------
    // Expose whether we're running under Electron with the preload API
    const isElectron = typeof window !== 'undefined' && !!window.api
    const statusEl = document.getElementById('status')

    // ---------------------------
    // Process list UI / IPC
    // ---------------------------
    async function fetchProcesses() {
      if (isElectron && window.api) {
        setStatus('Fetching processes...')
        try {
          const res = await window.api.getProcesses()
          if (!res || !res.ok) {
            setStatus('Failed to get processes: ' + (res && res.error ? res.error : 'unknown'))
            return []
          }
          setStatus('Last updated: ' + new Date().toLocaleTimeString())
          return res.list || []
        } catch (err) {
          setStatus('IPC error: ' + err.message)
          return []
        }
      } else {
        setStatus('Not running inside Electron — process info unavailable')
        return []
      }
    }

    function formatBytes(bytes) {
      if (!bytes && bytes !== 0) return ''
      const units = ['B','KB','MB','GB','TB']
      let i = 0
      let v = bytes
      while (v >= 1024 && i < units.length-1) { v /= 1024; i++ }
      return v.toFixed(1) + ' ' + units[i]
    }

    function formatElapsed(ms) {
      if (ms == null) return ''
      const s = Math.floor(ms / 1000)
      const days = Math.floor(s / 86400)
      const hrs = Math.floor((s % 86400) / 3600)
      const mins = Math.floor((s % 3600) / 60)
      const secs = s % 60
      if (days > 0) return `${days}d ${hrs}h ${mins}m`
      if (hrs > 0) return `${hrs}h ${mins}m ${secs}s`
      if (mins > 0) return `${mins}m ${secs}s`
      return `${secs}s`
    }

    // Client-side filter state
    let currentFilter = ''
    let filterTimer = null

    function applyFilter(list) {
      const f = (currentFilter || '').trim().toLowerCase()
      if (!f) return list
      const asNum = Number(f)
      return list.filter(p => {
        if (!Number.isNaN(asNum) && asNum > 0 && p.pid === asNum) return true
        const name = (p.name || p.command || '').toString().toLowerCase()
        return name.includes(f)
      })
    }

    function renderProcesses(list) {
      const tbody = document.querySelector('#procTable tbody')
      tbody.innerHTML = ''
      // Apply sorting if requested
      let working = Array.isArray(list) ? list.slice() : []
      if (sortKey) {
        working.sort((a, b) => {
          const va = Number(a[sortKey] || 0)
          const vb = Number(b[sortKey] || 0)
          return (va - vb) * (sortDir === 'asc' ? 1 : -1)
        })
      }
      const filtered = applyFilter(working)
      for (const p of filtered) {
        const tr = document.createElement('tr')
        tr.style.borderBottom = '1px solid #f0f0f0'
        tr.innerHTML = `
          <td style="width:6%">${p.pid}</td>
          <td style="width:32%">${escapeHtml(p.name || p.command || '')}</td>
          <td style="width:8%">${(p.cpu || 0).toFixed ? (p.cpu||0).toFixed(1) : p.cpu}</td>
          <td style="width:12%">${formatBytes(p.mem || 0)}</td>
          <td style="width:18%">${p.started ? new Date(p.started).toLocaleString() : ''}</td>
          <td style="width:12%">${formatElapsed(p.elapsed)}</td>
          <td style="width:12%">${p.status}</td>
        `
        tbody.appendChild(tr)
      }
    }

    // Sorting state
    let sortKey = null // 'cpu' or 'mem'
    let sortDir = 'desc' // 'asc' | 'desc'

    // Tab state
    let currentTab = 'all' // 'all' | 'ongoing'

    function setTab(t) {
      currentTab = t
      // update button styles
      const tabAll = document.getElementById('tabAll')
      const tabOngoing = document.getElementById('tabOngoing')
      if (tabAll) tabAll.style.background = t === 'all' ? '#eef6ff' : '#fff'
      if (tabOngoing) tabOngoing.style.background = t === 'ongoing' ? '#eef6ff' : '#fff'
      refreshAndRender()
    }

    function toggleSort(key) {
      if (sortKey === key) sortDir = sortDir === 'asc' ? 'desc' : 'asc'
      else { sortKey = key; sortDir = 'desc' }
      refreshAndRender()
      updateHeaderIndicators()
    }

    function updateHeaderIndicators() {
      const thCpu = document.getElementById('thCpu')
      const thMem = document.getElementById('thMem')
      if (thCpu) thCpu.textContent = 'CPU%' + (sortKey === 'cpu' ? (sortDir === 'asc' ? ' ▲' : ' ▼') : '')
      if (thMem) thMem.textContent = 'Mem' + (sortKey === 'mem' ? (sortDir === 'asc' ? ' ▲' : ' ▼') : '')
    }

    // Auto-refresh logic
    let autoRefreshTimer = null
  // Notification / alerting state
  const notifyCooldownMs = 5 * 60 * 1000 // 5 minutes between notifications per app
  const lastNotified = {} // map appName -> timestamp

    async function refreshAndRender() {
      const list = await fetchProcesses()
      // update ongoing count
      try {
        const ongoingCountEl = document.getElementById('ongoingCount')
        const ongoingCount = Array.isArray(list) ? list.filter(p => (p.status === 'ongoing') && (p.elapsed && p.elapsed > 60000)).length : 0
        if (ongoingCountEl) ongoingCountEl.textContent = String(ongoingCount)
      } catch (e) {}

      // If notify-on-active is enabled and a filter target exists, send a notification
      try {
        const notifyChk = document.getElementById('notifyOnActive')
        const target = (currentFilter || '').trim()
        if (notifyChk && notifyChk.checked && target) {
          // find a matching process (by PID or name substring) that is ongoing > 1min
          const match = (Array.isArray(list) ? list : []).find(p => {
            const isOngoing = p.status === 'ongoing' && p.elapsed && p.elapsed > 60000
            if (!isOngoing) return false
            const asNum = Number(target)
            if (!Number.isNaN(asNum) && asNum > 0) return p.pid === asNum
            const name = (p.name || p.command || '').toString().toLowerCase()
            return name.includes(target.toLowerCase())
          })
          if (match) {
            const appName = match.name || match.command || String(match.pid)
            const now = Date.now()
            const last = lastNotified[appName] || 0
            if (now - last > notifyCooldownMs) {
              // notify
              const minutes = Math.max(1, Math.floor((match.elapsed || 0) / 60000))
              const title = 'Focus reminder'
              const body = `You are on ${appName} for ${minutes} minute${minutes>1?'s':''}. Let's get back to work`
              try {
                if (isElectron && window.api) {
                  // register listener for eventual user action
                  const unsub = window.api.onNotificationResponse((data) => {
                    try { setStatus('User chose: ' + (data && data.result ? data.result : 'unknown')) } catch (e) {}
                    try { unsub() } catch (e) {}
                  })
                  // ask main process to show a system notification (don't force dialog)
                  try {
                    const result = await window.api.showNotification({ title, body, useDialog: false })
                    // If main process returned a dialog response synchronously (fallback), show it immediately
                    if (result && result.dialog) {
                      const resp = result.response
                      setStatus('User chose: ' + (resp === 0 ? 'okay' : 'cancel'))
                      try { unsub() } catch (e) {}
                    }
                  } catch (e) {
                    // ignore
                  }
                } else {
                  // Fallback: browser notification
                  if (Notification.permission === 'granted') new Notification(title, { body })
                }
              } catch (e) {
                // ignore
              }
              lastNotified[appName] = now
            }
          }
        }
      } catch (e) {}

      // If currentTab is 'ongoing', filter list before rendering
      if (currentTab === 'ongoing') {
        const filteredList = (Array.isArray(list) ? list : []).filter(p => (p.status === 'ongoing') && (p.elapsed && p.elapsed > 60000))
        renderProcesses(filteredList)
      } else {
        renderProcesses(list)
      }
    }

    function startAutoRefresh() {
      stopAutoRefresh()
      const interval = Math.max(1, Number(document.getElementById('autoInterval').value || 5)) * 1000
      autoRefreshTimer = setInterval(refreshAndRender, interval)
      // run immediately
      refreshAndRender()
    }

    function stopAutoRefresh() {
      if (autoRefreshTimer) { clearInterval(autoRefreshTimer); autoRefreshTimer = null }
    }

    document.addEventListener('DOMContentLoaded', () => {
      const refreshBtn = document.getElementById('refreshProcs')
      const filterInput = document.getElementById('procFilter')
      const autoChk = document.getElementById('autoRefreshChk')
      const intervalInput = document.getElementById('autoInterval')

      if (refreshBtn) {
        refreshBtn.addEventListener('click', async () => {
          const list = await fetchProcesses()
          renderProcesses(list)
        })
      }

      if (filterInput) {
        filterInput.addEventListener('input', (ev) => {
          currentFilter = ev.target.value || ''
          // debounce render
          if (filterTimer) clearTimeout(filterTimer)
          filterTimer = setTimeout(async () => { const l = await fetchProcesses(); renderProcesses(l) }, 250)
        })
      }

      // Load persisted auto-refresh preference
      try {
        const savedAuto = localStorage.getItem('proc_auto_refresh')
        if (savedAuto !== null) autoChk.checked = savedAuto === '1'
        const savedInterval = localStorage.getItem('proc_auto_interval')
        if (savedInterval) intervalInput.value = Number(savedInterval)
        const savedNotify = localStorage.getItem('proc_notify_active')
        const notifyChk = document.getElementById('notifyOnActive')
        if (notifyChk && savedNotify !== null) notifyChk.checked = savedNotify === '1'
      } catch (e) { /* ignore storage errors */ }

      if (autoChk) {
        autoChk.addEventListener('change', (ev) => {
          try { localStorage.setItem('proc_auto_refresh', ev.target.checked ? '1' : '0') } catch (e) {}
          if (ev.target.checked) startAutoRefresh()
          else stopAutoRefresh()
        })
      }

      // Persist notify-on-active preference
      const notifyChk = document.getElementById('notifyOnActive')
      if (notifyChk) {
        notifyChk.addEventListener('change', (ev) => {
          try { localStorage.setItem('proc_notify_active', ev.target.checked ? '1' : '0') } catch (e) {}
        })
      }

      if (intervalInput) {
        intervalInput.addEventListener('change', (ev) => {
          try { localStorage.setItem('proc_auto_interval', String(ev.target.value)) } catch (e) {}
          if (autoChk && autoChk.checked) startAutoRefresh()
        })
      }

      // Hook up sorting header clicks
      const thCpu = document.getElementById('thCpu')
      const thMem = document.getElementById('thMem')
      if (thCpu) thCpu.addEventListener('click', () => toggleSort('cpu'))
      if (thMem) thMem.addEventListener('click', () => toggleSort('mem'))
      updateHeaderIndicators()

  // Hook up tabs
  const tabAll = document.getElementById('tabAll')
  const tabOngoing = document.getElementById('tabOngoing')
  if (tabAll) tabAll.addEventListener('click', () => setTab('all'))
  if (tabOngoing) tabOngoing.addEventListener('click', () => setTab('ongoing'))

      // Auto-load once (still useful if auto-refresh disabled)
      setTimeout(async () => { const l = await fetchProcesses(); renderProcesses(l) }, 500)

      // If auto-refresh is checked by default, start polling immediately
      try {
        if (autoChk && autoChk.checked) startAutoRefresh()
      } catch (e) {
        // ignore if DOM isn't ready somehow
      }
    })

    function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"})[c]) }

    document.addEventListener('DOMContentLoaded', () => {
      const refreshBtn = document.getElementById('refreshProcs')
      if (refreshBtn) {
        refreshBtn.addEventListener('click', async () => {
          const list = await fetchProcesses()
          renderProcesses(list)
        })
      }
      // Auto-load once
      setTimeout(async () => { const l = await fetchProcesses(); renderProcesses(l) }, 500)
    })

      function setStatus(msg) {
        if (statusEl) statusEl.textContent = msg
      }

      document.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('notifyBtn')

        if (!isElectron) {
          setStatus('Not running inside Electron; notifications will use browser API')
        }

        btn.addEventListener('click', async () => {
          const title = 'Research 1.0'
          const body = 'This is a notification from the app.'

          if (isElectron && window.api) {
            // Register a one-time listener for the notification response
            const unsub = window.api.onNotificationResponse((data) => {
              if (data && data.result) setStatus('User chose: ' + data.result)
              console.log('Notification response', data)
              try { unsub() } catch (e) {}
            })

            try {
              await window.api.showNotification({ title, body, useDialog: false })
            } catch (err) {
              console.error('IPC error invoking notification:', err)
              setStatus('Failed to show notification: ' + err.message)
            }
          } else {
            // Fallback to HTML5 Notification in browser
            try {
              if (Notification.permission === 'granted') {
                new Notification(title, { body })
              } else {
                const p = await Notification.requestPermission()
                setStatus('Notification permission: ' + p)
                if (p === 'granted') new Notification(title, { body })
              }
            } catch (err) {
              console.error('Browser notification failed:', err)
              alert('Notification failed: ' + err.message)
            }
          }
        })
        // (Removed: previous dialog/toast button and handler)
      })

      // ---------------------------
      // In-app toast implementation
      // ---------------------------
      function ensureToastContainer() {
        let c = document.querySelector('.toast-container')
        if (!c) {
          c = document.createElement('div')
          c.className = 'toast-container'
          document.body.appendChild(c)
        }
        return c
      }

      function showToast({ title, body, timeout = 8000 } = {}) {
        return new Promise((resolve, reject) => {
          try {
            const container = ensureToastContainer()
            const t = document.createElement('div')
            t.className = 'toast'

            const msg = document.createElement('div')
            msg.className = 'msg'
            msg.innerHTML = '<strong>' + (title || '') + '</strong><div style="font-size:13px;color:#444;margin-top:6px;">' + (body || '') + '</div>'

            const actions = document.createElement('div')
            actions.className = 'actions'

            const okBtn = document.createElement('button')
            okBtn.className = 'primary'
            okBtn.textContent = 'Okay'
            okBtn.addEventListener('click', () => {
              cleanup('okay')
            })

            const cancelBtn = document.createElement('button')
            cancelBtn.textContent = 'Cancel'
            cancelBtn.addEventListener('click', () => {
              cleanup('cancel')
            })

            actions.appendChild(okBtn)
            actions.appendChild(cancelBtn)

            t.appendChild(msg)
            t.appendChild(actions)

            container.appendChild(t)

            const tid = setTimeout(() => {
              cleanup('closed')
            }, timeout)

            function cleanup(result) {
              clearTimeout(tid)
              t.style.transition = 'opacity 180ms ease, transform 180ms ease'
              t.style.opacity = '0'
              t.style.transform = 'translateY(6px)'
              setTimeout(() => {
                try { container.removeChild(t) } catch (e) {}
                resolve(result)
              }, 200)
            }
          } catch (err) {
            reject(err)
          }
        })
      }
    </script>
  </body>
</html>
